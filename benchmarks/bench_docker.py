#!/usr/bin/env python3
import os
import re
import sys
import argparse
import subprocess
import datetime
import csv
import shutil

# --- Configuration ---
# The path inside the container where the host's CWD will be mounted.
CONTAINER_WORK_DIR = "/work"

def check_tools():
    """Check if required host tools (docker, time, timeout) exist."""
    if not shutil.which("docker"):
        print("Error: 'docker' command not found. Is Docker installed and in your PATH?")
        sys.exit(1)
    # The check for time/timeout is now implicitly handled by the Docker container.
    # We assume the specified image has them. A good practice would be to ensure
    # the Docker image is built with 'coreutils' and 'time' packages.
    print("[INFO] Docker command found.")

def get_inner_benchmark_command(script_path, extra_args, instance_path):
    """
    Constructs the benchmark command to be run *inside* the container.
    - Assumes 'python3' for .py files.
    - Uses container-relative paths.
    """
    cmd = []
    
    # Use 'python3' for .py scripts, assuming it's in the container's PATH
    if script_path.endswith('.py'):
        cmd.append('python3')
        cmd.append(script_path)
    else:
        # Assumes the script is an executable in the container's PATH or at the specified path
        cmd.append(script_path)
    
    if extra_args:
        cmd.extend(extra_args)
        
    cmd.append(instance_path)
    return cmd

def parse_time_output(stats_file):
    """
    Parses the output file generated by GNU time.
    Format used: %e,%M,%x (Real Time, Max RSS, Exit Code)
    """
    try:
        with open(stats_file, 'r') as f:
            content = f.read().strip()
            # Only use last line.
            content = content.splitlines()[-1]
            parts = content.split(',')
            if len(parts) >= 3:
                return {
                    'time': parts[0], # Seconds
                    'memory': parts[1], # Kilobytes
                    'exit_code': parts[2]
                }
    except Exception as e:
        print(f"\n[Warning] Could not parse time stats from {stats_file}: {e}")
    
    return {'time': '0', 'memory': '0', 'exit_code': '-1'}

def sanitize_for_container_name(name):
    """Sanitizes a string to be a valid Docker container name component."""
    name = re.sub(r'[^a-zA-Z0-9_.-]', '_', name)
    return name

def main():
    parser = argparse.ArgumentParser(
        description="Automated Benchmark Runner using Docker",
        usage="%(prog)s --docker-image IMAGE --timeout TIMEOUT --folder FOLDER --script SCRIPT [options] [-- script_args ...]"
    )
    
    # Required arguments
    parser.add_argument('--docker-image', required=True, help="Name of the Docker image to use for benchmarking")
    parser.add_argument('--timeout', required=True, help="Timeout string (e.g., 60s, 10m)")
    parser.add_argument('--folder', required=True, help="Path to folder with benchmark instances")    
    
    # Optional arguments
    parser.add_argument('--match', help="Only consider files matching this regular expression")
    parser.add_argument('--docker-script', help="Path to the benchmark script/binary in the docker container; Defaults to `/run.sh`.")
    parser.add_argument('--user-script', help="Path to the benchmark script/binary relative to CWD. User script and docker script cannot be set at the same time.")
    
    # Catch-all for arguments to be passed to the benchmark script
    parser.add_argument('script_args', nargs=argparse.REMAINDER, help="Arguments passed to the benchmark script")

    args = parser.parse_args()
    
    # 0. Pre-flight checks
    check_tools()
    
    if args.docker_script and args.user_script:
        print(f"[FATAL] Cannot specify both a Docker script and user script.")
        sys.exit(1)

    if not args.docker_script and not args.user_script:
        args.docker_script = "/run.sh"

    pass_through_args = args.script_args
    if pass_through_args and pass_through_args[0] == '--':
        pass_through_args = pass_through_args[1:]

    # 1. Setup Output Directory
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    output_dir = f"run_{timestamp}"
    
    try:
        os.makedirs(output_dir, exist_ok=True)
        print(f"[INFO] Created output directory: {output_dir}")
    except OSError as e:
        print(f"[FATAL] Could not create output directory: {e}")
        sys.exit(1)

    # 2. Load and Sort Files
    if not os.path.isdir(args.folder):
        print(f"[FATAL] Benchmark folder not found: {args.folder}")
        sys.exit(1)

    files = [f for f in os.listdir(args.folder) if os.path.isfile(os.path.join(args.folder, f))]
    
    if args.match:
        files = [f for f in files if bool(re.fullmatch(args.match, os.path.basename(f)))]
    
    files.sort()
    
    if not files:
        print(f"[WARN] No files found in {args.folder} matching criteria.")
        sys.exit(0)

    print(f"[INFO] Found {len(files)} instances to process.")
    print(f"[INFO] Docker image: {args.docker_image}")
    print(f"[INFO] Timeout set to: {args.timeout}")
    print(f"[INFO] Benchmark script: { args.docker_script if args.user_script is None else args.user_script }")
    if pass_through_args:
        print(f"[INFO] Extra args: {' '.join(pass_through_args)}")

    # 3. Prepare CSV and path variables
    csv_path = os.path.join(output_dir, "__results.csv")
    csv_header = ["Instance", "Status", "Runtime_sec", "Memory_KB", "ExitCode"]
    host_cwd = os.path.abspath(os.getcwd())

    # 4. Processing Loop
    try:
        with open(csv_path, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(csv_header)
            
            for i, filename in enumerate(files):
                print(f"[{i+1}/{len(files)}] Running {filename}...", end=" ", flush=True)

                # --- Unique Container Name ---
                sanitized_filename = sanitize_for_container_name(os.path.splitext(filename)[0])
                container_name = f"benchmark-{timestamp}-{sanitized_filename}"

                # --- Path Translation ---
                # All paths must be relative to the CWD to work with the volume mount.
                # We convert to absolute paths first, then get the relative path to CWD.
                # This makes the script robust to how paths are provided.
                def to_container_path(host_path):
                    abs_host_path = os.path.abspath(host_path)
                    relative_path = os.path.relpath(abs_host_path, host_cwd)
                    return os.path.join(CONTAINER_WORK_DIR, relative_path)

                container_instance_path = to_container_path(os.path.join(args.folder, filename))
                if args.user_script:
                    container_script_path = to_container_path(args.user_script)
                else:
                    container_script_path = args.docker_script
                container_log_path = to_container_path(os.path.join(output_dir, f"{filename}.log"))
                container_stats_path = to_container_path(os.path.join(output_dir, f"{filename}.stats"))
                
                # Host path for parsing the stats file after the run
                host_stats_path = os.path.join(output_dir, f"{filename}.stats")

                # --- Command Construction ---
                inner_cmd = get_inner_benchmark_command(
                    container_script_path, 
                    pass_through_args, 
                    container_instance_path
                )

                # Command to run INSIDE the container, with output redirected to the log file.
                # Note: We must use a shell (`/bin/sh -c "..."`) to handle the redirection `>` correctly.
                container_shell_cmd = (
                    f'/usr/bin/time -f "%e,%M,%x" -o {container_stats_path} '
                    f'timeout {args.timeout} {" ".join(inner_cmd)} '
                    f'> {container_log_path} 2>&1'
                )

                docker_cmd = [
                    'docker', 'run',
                    '--rm',  # Clean up the container after it exits
                    '--init', # Run with minimal "init" environment that cleans up zombie processes
                    '--name', container_name, # Assign a name for cleanup
                    '-v', f'{host_cwd}:{CONTAINER_WORK_DIR}', # Mount CWD
                    '-w', CONTAINER_WORK_DIR, # Set working directory
                    args.docker_image,
                    '/bin/sh', '-c', container_shell_cmd
                ]

                proc = None
                status = "UNKNOWN"
                try:
                    # Use Popen to get control over the running process
                    proc = subprocess.Popen(docker_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    proc.wait() # Wait for the docker client process to finish
                
                except KeyboardInterrupt:
                    print("\n[INFO] Interruption detected. Stopping Docker container...", end="", flush=True)
                    # Use `docker stop` which sends SIGTERM, then SIGKILL. It's cleaner.
                    # The container will be auto-removed because of the `--rm` flag.
                    subprocess.run(['docker', 'stop', container_name], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    print(f" stopped.")
                    # Re-raise the exception to terminate the whole script gracefully
                    raise
                
                runtime = 0
                memory = 0
                exit_code = 0

                try:                                    
                    stats = parse_time_output(host_stats_path)
                    runtime = stats['time']
                    memory = stats['memory']
                    exit_code = int(stats['exit_code'])
                    
                    if exit_code == 124:
                        status = "TIMEOUT"
                        print(f"-> TIMEOUT ({runtime}s)")
                    elif exit_code == 0:
                        status = "OK"
                        print(f"-> OK ({runtime}s)")
                    else:
                        status = "ERROR"
                        print(f"-> ERROR (Code: {exit_code})")

                except Exception as e:
                    print(f"\n[ERROR] Docker execution failed: {e}")
                    status = "SYSTEM_ERROR"

                # For the sake of completeness, we are also keeping the stats files.
                # if os.path.exists(host_stats_path):
                #     os.remove(host_stats_path)

                writer.writerow([filename, status, runtime, memory, exit_code])
                csvfile.flush()

    except KeyboardInterrupt:
        print("\n[INFO] Benchmark interrupted by user. Exiting...")
        sys.exit(130)

    print(f"\n[INFO] Benchmarking complete. Results saved to {csv_path}")

if __name__ == "__main__":
    main()